<html>
  <head>
    <style>
     body, html {
         margin: 0;
         padding: 0;
     }
     a, a:active, a:hover, a:focus {
         color: inherit;
     }
     #header {
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         background-color: rgba(255, 255, 255, 0.9);
         border-bottom: 1px solid #ccc;
         padding: 10px;
         z-index: 1000;
         display: flex;
         justify-content: space-between;
         align-items: start;
         font-family: system-ui;
     }
     #countdown {
         font-size: 48px;
         font-weight: bold;
         color: #a95226;
         position: relative;
     }
     .countdown-particle {
         position: absolute;
         width: 4px;
         height: 4px;
         border-radius: 50%;
         background-color: #a95226;
         pointer-events: none;
     }
     #gameControls {
         position: absolute;
         gap: 10px;
         right: 4em;
         top: 1.25em;
     }
     #gameControls button {
         padding: 8px 16px;
         font-size: 14px;
         border-radius: 5px;
         border: 1px solid #ccc;
         background-color: white;
         cursor: pointer;
     }
     #gameControls button:hover {
         background-color: #f0f0f0;
     }
     #chipTray {
         position: absolute;
         left: 50%;
         transform: translateX(-50%);
         display: flex;
         gap: 10px;
         align-items: center;
     }
     .chip {
         width: 40px;
         height: 40px;
         border-radius: 50%;
         border: 3px solid white;
         display: flex;
         align-items: center;
         justify-content: center;
         font-family: serif;
         font-weight: bold;
         color: white;
         cursor: grab;
         box-shadow: 0 2px 4px rgba(0,0,0,0.3);
     }
     .chip:active {
         cursor: grabbing;
     }
     body.dragging, body.dragging * {
         cursor: grabbing !important;
     }
     .chip.red { background-color: #dc3545; }
     .placed-chip {
         position: absolute;
         cursor: grab;
         z-index: 999;
     }
     .ghost-chip {
         position: absolute;
         pointer-events: none;
         opacity: 0.4;
         z-index: 998;
     }
     #chipPile {
         position: relative;
     }
     #chipCount {
         font-size: 24px;
     }
     #content {
         margin-top: 120px;
         padding: 1em;
         user-select: none;
         -webkit-user-select: none;
     }
     ins { background-color: #90EE90; text-decoration: none; }
     del { background-color: #FFB6C1; }

     #startScreen {
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         min-height: 100vh;
         gap: 20px;
         padding: 20px;
         box-sizing: border-box;
     }
     #startScreen h1 {
         margin: 0 0 20px 0;
     }
     #startScreen input, #startScreen button {
         padding: 10px 15px;
         font-size: 16px;
         border-radius: 5px;
         border: 1px solid #ccc;
     }
     #startScreen input {
         width: 300px;
     }
     #startScreen button {
         background-color: #007bff;
         color: white;
         border: none;
         cursor: pointer;
     }
     #startScreen button:hover {
         background-color: #0056b3;
     }
     #startScreen button:disabled {
         background-color: #ccc;
         cursor: not-allowed;
     }
     #startScreen button#startGameBtn {
         background-color: #007bff;
         font-size: 28px;
     }
     .inputGroup {
         display: flex;
         flex-direction: column;
         gap: 10px;
         width: 300px;
         border-radius: 10px;
     }
     .inputGroup label {
         font-weight: bold;
     }
     #articleInfo {
         color: #666;
         font-style: italic;
     }
     #shareUrl {
         width: 400px;
         font-size: 14px;
         background-color: #f5f5f5;
     }
     .shareUrlContainer {
         display: flex;
         gap: 10px;
         align-items: center;
     }
     #copyShareUrlBtn {
         padding: 8px 16px;
         font-size: 14px;
         border-radius: 5px;
         border: 1px solid #ccc;
         background-color: white;
         cursor: pointer;
     }
     #copyShareUrlBtn:hover {
         background-color: #f0f0f0;
     }
     .hidden {
         display: none !important;
     }
     #gameOverScreen {
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         bottom: 0;
         background-color: rgba(0, 0, 0, 0.8);
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         z-index: 2000;
         gap: 20px;
     }
     #gameOverScreen h2 {
         color: white;
         font-size: 48px;
         margin: 0;
     }
     #gameOverScreen .inputGroup {
         background-color: white;
         padding: 20px;
     }
     #gameOverScreen button {
         padding: 15px 30px;
         font-size: 18px;
         background-color: #28a745;
         color: white;
         border: none;
         border-radius: 5px;
         cursor: pointer;
     }
     #gameOverScreen button:hover {
         background-color: #218838;
     }
     #gameOverScreen #endGameFromOverBtn {
         background-color: #dc3545;
     }
     #gameOverScreen #endGameFromOverBtn:hover {
         background-color: #c82333;
     }
     #endGameScreen {
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         bottom: 0;
         background-color: rgba(0, 0, 0, 0.8);
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         z-index: 2000;
         gap: 20px;
     }
     #endGameScreen h2 {
         color: white;
         font-size: 48px;
         margin: 0;
     }
     #endGameScreen .stats {
         background-color: white;
         padding: 30px;
         border-radius: 10px;
         font-size: 18px;
     }
     #endGameScreen .stats div {
         margin: 10px 0;
     }
     #endGameScreen .stats div:last-child {
         font-size: 30px;
     }
     #endGameScreen button {
         padding: 15px 30px;
         font-size: 18px;
         background-color: #007bff;
         color: white;
         border: none;
         border-radius: 5px;
         cursor: pointer;
     }
     #endGameScreen button:hover {
         background-color: #0056b3;
     }
    </style>
  </head>
  <body>
    <div id="gameOverScreen" class="hidden">
      <h2>Out of chips!</h2>
      <div class="inputGroup">
        <label for="insertChipsInput">Insert chips to continue:</label>
        <input type="number" id="insertChipsInput" value="5" min="1" max="20">
      </div>
      <button id="continueBtn">Continue</button>
      <button id="endGameFromOverBtn">End game</button>
    </div>

    <div id="endGameScreen" class="hidden">
      <h2>Game summary</h2>
      <div class="stats">
        <div><strong>Article:</strong> <span id="endArticle"></span></div>
        <div><strong>Current revision:</strong> <span id="endRevision"></span></div>
        <div><strong>Revision date:</strong> <span id="endRevisionDate"></span></div>
        <hr>
        <div><strong>Total chips inserted:</strong> <span id="endChipsInserted"></span></div>
        <div><strong>Total chips won:</strong> <span id="endChipsWon"></span></div>
        <div><strong>Current chips:</strong> <span id="endCurrentChips"></span></div>
        <div><strong>Net gain/loss:</strong> <span id="endNetGain"></span></div>
      </div>
      <button id="returnToStartBtn">Return to start</button>
    </div>

    <div id="startScreen">
      <h1>Wikibet</h1>

      <div id="gameDescription">
        <p>Click on the article to place chips to bet on where you think edits
          will happen in the next round.</p>
        <p>Every round, if an edit touches one of your chips, you win <span id="multiplierText">3x</span> its value.
          When no edits touch a chip, you lose it.</p>
      </div>

      <div class="inputGroup">
        <label for="articleInput">Article name:</label>
        <input type="text" id="articleInput" placeholder="Enter article name (e.g., Apple Inc.)">
        <button id="randomArticleBtn">Random article</button>
      </div>

      <div id="articleInfo"></div>

      <div class="inputGroup">
        <label for="shareUrl">Share this URL to play this exact game:</label>
        <div class="shareUrlContainer">
          <input type="text" id="shareUrl" readonly>
          <button id="copyShareUrlBtn">Copy</button>
        </div>
      </div>

      <button id="startGameBtn" disabled>Start game</button>

      <details>
        <summary>Advanced options</summary>

        <div class="inputGroup">
          <label for="chipCountInput">Starting chips (higher is easier):</label>
          <input type="number" id="chipCountInput" value="15" min="1" max="20">
        </div>

        <div class="inputGroup">
          <label for="countdownInput">Timer per round (seconds):</label>
          <input type="number" id="countdownInput" value="4" min="1" max="30">
        </div>

        <div class="inputGroup">
          <label for="multiplierInput">Reward multiplier (higher is easier):</label>
          <input type="number" id="multiplierInput" value="3" min="1" max="10">
        </div>
      </details>
    </div>

    <div id="container" class="hidden">
      <div id="header">
        <div id="headerInfo">
        </div>
        <div id="chipTray">
          <div id="chipPile" class="chip red">
            <span id="chipPileCount">15</span>
          </div>
        </div>
        <div id="gameControls">
          <button id="clearBetsBtn">Clear all bets</button>
          <button id="endGameBtn">End game</button>
          <button id="pauseBtn">Pause</button>
        </div>
        <div id="countdown">4</div>
      </div>

      <div id="content"></div>
    </div>

    <script>
     // Polyfill for CommonJS module.exports in browser
     var module = { exports: {} };
    </script>
    <script src="vendor/htmldiff.js"></script>
    <script>
     const htmldiff = module.exports.default;

     let allRevisions = [];
     let revisionHtml = [];
     let currentRevisionIndex = 0;
     let pageTitle = '';
     let countdownInterval = null;
     let draggedChip = null;
     let chipCount = 15;
     let selectedArticle = null;
     let countdownTime = 4;
     let rewardMultiplier = 3;
     let isPaused = false;
     let isGameEnded = false;
     let pausedCountdown = 0;
     let totalChipsInserted = 0;
     let totalChipsWon = 0;
     let startingChips = 5;

     // Web Audio API setup for concurrent sound effects
     const audioCtx = new AudioContext();
     let coinBuffer = null;
     let hurtBuffer = null;
     let selectBuffer = null;
     let countdownBuffer = null;

     // Load audio buffers
     async function loadAudioBuffers() {
       try {
         const [coinResp, hurtResp, selectResp, countdownResp] = await Promise.all([
           fetch('res/coin.wav'),
           fetch('res/hurt.wav'),
           fetch('res/select.wav'),
           fetch('res/countdown.wav')
         ]);
         const [coinArrayBuffer, hurtArrayBuffer, selectArrayBuffer, countdownArrayBuffer] = await Promise.all([
           coinResp.arrayBuffer(),
           hurtResp.arrayBuffer(),
           selectResp.arrayBuffer(),
           countdownResp.arrayBuffer()
         ]);
         [coinBuffer, hurtBuffer, selectBuffer, countdownBuffer] = await Promise.all([
           audioCtx.decodeAudioData(coinArrayBuffer),
           audioCtx.decodeAudioData(hurtArrayBuffer),
           audioCtx.decodeAudioData(selectArrayBuffer),
           audioCtx.decodeAudioData(countdownArrayBuffer)
         ]);
       } catch (e) {
         console.log('Failed to load audio:', e);
       }
     }

     // Track currently playing sounds
     let currentSounds = [];

     // Play sound using AudioBuffer
     function playSound(buffer, volume = 1.0) {
       if (!buffer) return;
       const source = audioCtx.createBufferSource();
       const gainNode = audioCtx.createGain();
       source.buffer = buffer;
       gainNode.gain.value = volume;
       source.connect(gainNode);
       gainNode.connect(audioCtx.destination);
       source.start();

       // Track this sound
       currentSounds.push(source);

       // Remove from tracking when finished
       source.onended = () => {
         const index = currentSounds.indexOf(source);
         if (index > -1) {
           currentSounds.splice(index, 1);
         }
       };
     }

     // Stop all currently playing sounds
     function stopAllSounds() {
       currentSounds.forEach(source => {
         try {
           source.stop();
         } catch (e) {
           // Already stopped
         }
       });
       currentSounds = [];
     }

     // Countdown particle effects
     function createCountdownParticles(count) {
       const countdownEl = countdown;
       if (!countdownEl || count > 3 || count < 0) return;

       // Calculate intensity based on countdown (3=low, 2=medium, 1=high, 0=highest)
       const particleCount = count === 3 ? 8 : count === 2 ? 16 : count === 1 ? 24 : 32;
       const speed = count === 3 ? 30 : count === 2 ? 40 : count === 1 ? 50 : 60;

       const rect = countdownEl.getBoundingClientRect();
       const centerX = rect.width / 2;
       const centerY = rect.height / 2;

       for (let i = 0; i < particleCount; i++) {
         const particle = document.createElement('div');
         particle.className = 'countdown-particle';

         const angle = (i / particleCount) * Math.PI * 2;
         const startRadius = 30;

         particle.style.left = centerX + 'px';
         particle.style.top = centerY + 'px';
         particle.style.opacity = '1';

         countdownEl.appendChild(particle);

         // Animate particle
         const duration = 800;
         const startTime = Date.now();

         const animate = () => {
           const elapsed = Date.now() - startTime;
           const progress = elapsed / duration;

           if (progress >= 1) {
             particle.remove();
             return;
           }

           const currentRadius = startRadius + (speed * progress);
           const x = centerX + Math.cos(angle) * currentRadius;
           const y = centerY + Math.sin(angle) * currentRadius;

           particle.style.left = x + 'px';
           particle.style.top = y + 'px';
           particle.style.opacity = (1 - progress);

           requestAnimationFrame(animate);
         };

         requestAnimationFrame(animate);
       }
     }

     // Load audio on startup
     loadAudioBuffers();

     async function scoreRound() {
       // Check placed chips after content is rendered
       if (currentRevisionIndex == 0) {
         return;
       }

       const placedChips = Array.from(document.querySelectorAll('.placed-chip'));

       for (let i = 0; i < placedChips.length; i++) {
         const chip = placedChips[i];

         // Scroll chip into view if needed
         const headerHeight = header.offsetHeight;
         chip.scrollIntoView({ behavior: 'smooth', block: 'center' });

         const chipRect = chip.getBoundingClientRect();

         // Check if chip intersects with any ins or del element
         let isOnChange = false;
         const changes = document.querySelectorAll('ins, del');
         for (const change of changes) {
           const changeRect = change.getBoundingClientRect();

           // Check if rectangles intersect
           if (!(chipRect.right < changeRect.left ||
                 chipRect.left > changeRect.right ||
                 chipRect.bottom < changeRect.top ||
                 chipRect.top > changeRect.bottom)) {
             isOnChange = true;
             break;
           }
         }

         // Get chip value
         const chipValue = parseInt(chip.textContent);

         // Play sound effect
         playSound(isOnChange ? coinBuffer : hurtBuffer);

         // Create overlay animation
         const overlay = document.createElement('div');
         overlay.textContent = isOnChange ? `+${chipValue * rewardMultiplier}` : `-${chipValue}`;
         overlay.style.position = 'absolute';
         overlay.style.left = chip.style.left;
         overlay.style.top = chip.style.top;
         overlay.style.fontSize = '24px';
         overlay.style.fontWeight = 'bold';
         overlay.style.color = isOnChange ? 'green' : 'red';
         overlay.style.zIndex = '1002';
         overlay.style.pointerEvents = 'none';
         overlay.style.transition = 'opacity 2s, transform 2s';
         overlay.style.transform = 'translateY(0)';
         document.body.appendChild(overlay);

         // Animate and remove
         setTimeout(() => {
           overlay.style.opacity = '0';
           overlay.style.transform = 'translateY(-20px)';
         }, 0);

         setTimeout(() => {
           overlay.remove();
         }, 2000);

         // Update chip count and remove chip
         if (isOnChange) {
           const chipsWon = chipValue * rewardMultiplier;
           chipCount += chipsWon;
           totalChipsWon += chipsWon - chipValue;
         }
         chip.remove();

         chipPileCount.textContent = chipCount;

         // Wait 300ms before next chip
         if (i < placedChips.length - 1) {
           await new Promise(resolve => setTimeout(resolve, 300));
         }
       }

       // Check if game over
       if (chipCount === 0) {
         clearInterval(countdownInterval);
         gameOverScreen.classList.remove('hidden');
       }
     }

     // Create ghost chip
     let ghostChip = null;
     function createGhostChip() {
       if (!ghostChip) {
         ghostChip = document.createElement('div');
         ghostChip.className = 'chip ghost-chip red';
         ghostChip.style.display = 'none';
         document.body.appendChild(ghostChip);
       }
       return ghostChip;
     }
     createGhostChip();

     // Track if mouse is over content and last position
     let isOverContent = false;
     let lastMouseX = 0;
     let lastMouseY = 0;
     let lastShiftState = false;

     function updateGhostChip(shiftKey) {
       if (!isOverContent || chipCount <= 0 || draggedChip != null) {
         ghostChip.style.display = 'none';
         return;
       }

       const chipValue = shiftKey ? Math.min(rewardMultiplier, chipCount) : 1;
       ghostChip.textContent = chipValue;
       ghostChip.style.display = 'flex';
       ghostChip.style.left = (lastMouseX - 20) + 'px';
       ghostChip.style.top = (lastMouseY - 20) + 'px';
     }

     // Show/hide ghost chip on content hover
     content.addEventListener('pointermove', (e) => {
       lastMouseX = e.pageX;
       lastMouseY = e.pageY;
       isOverContent = true;

       if (chipCount <= 0 || draggedChip != null) {
         ghostChip.style.display = 'none';
         return;
       }

       // Check if hovering over an existing chip
       if (e.target.classList.contains('placed-chip') || e.target.closest('.placed-chip')) {
         ghostChip.style.display = 'none';
         isOverContent = false;
         return;
       }

       lastShiftState = e.shiftKey;
       updateGhostChip(e.shiftKey);
     });

     content.addEventListener('pointerleave', () => {
       isOverContent = false;
       ghostChip.style.display = 'none';
     });

     // Update ghost chip on Shift key press/release
     document.addEventListener('keydown', (e) => {
       if (e.key === 'Shift' && lastShiftState !== true) {
         lastShiftState = true;
         updateGhostChip(true);
       }
     });

     document.addEventListener('keyup', (e) => {
       if (e.key === 'Shift' && lastShiftState !== false) {
         lastShiftState = false;
         updateGhostChip(false);
       }
     });

     // Click on content to place chip
     content.addEventListener('pointerdown', (e) => {
       if (chipCount <= 0) return;
       if (draggedChip != null) return;

       // Check if we clicked on an existing placed chip or inside one
       if (e.target.classList.contains('placed-chip') || e.target.closest('.placed-chip')) {
         return; // Let the chip's own handler deal with it
       }

       // Prevent default behavior (especially text selection on Shift-click)
       e.preventDefault();

       // Determine chip value based on Shift key
       const chipsToPlace = e.shiftKey ? Math.min(rewardMultiplier, chipCount) : 1;

       // Decrement chip count
       chipCount -= chipsToPlace;
       chipPileCount.textContent = chipCount;

       // Create chip at click location
       const chip = document.createElement('div');
       chip.className = 'chip placed-chip red';
       chip.textContent = chipsToPlace;
       chip.style.left = (e.pageX - 20) + 'px';
       chip.style.top = (e.pageY - 20) + 'px';
       chip.style.cursor = 'grab';

       chip.addEventListener('pointerdown', (e) => {
         e.stopPropagation();
         startDragging(chip, false, e);
       });

       document.body.appendChild(chip);
     });

     // Shared drag logic
     function startDragging(chip, fromPile, e) {
       e.preventDefault();
       e.stopPropagation();

       if (draggedChip != null) return;

       draggedChip = chip;
       draggedChip.style.zIndex = '1001'; // Above header while dragging
       document.body.classList.add('dragging');

       // Capture pointer to ensure we get all move events
       e.target.setPointerCapture(e.pointerId);

       let hasMoved = false;
       const startX = e.pageX;
       const startY = e.pageY;
       const isShiftKey = e.shiftKey;

       const onPointerMove = (e) => {
         if (draggedChip) {
           draggedChip.style.left = (e.pageX - 20) + 'px';
           draggedChip.style.top = (e.pageY - 20) + 'px';

           // Check if moved more than a few pixels
           if (Math.abs(e.pageX - startX) > 5 || Math.abs(e.pageY - startY) > 5) {
             hasMoved = true;
           }
         }
       };

       const onPointerUp = (e) => {
         document.body.removeEventListener('pointermove', onPointerMove);
         document.body.removeEventListener('pointerup', onPointerUp);
         document.body.classList.remove('dragging');

         // Check if clicked on an existing placed chip (not moved)
         if (!hasMoved && !fromPile) {
           const incrementAmount = Math.min(chipCount, isShiftKey ? rewardMultiplier : 1);
           draggedChip.textContent = parseInt(draggedChip.textContent) + incrementAmount;
           chipCount -= incrementAmount;
           chipPileCount.textContent = chipCount;
           draggedChip = null;
           return;
         }

         // Check if pointer is inside header
         const headerRect = header.getBoundingClientRect();
         if ((e.clientX >= headerRect.left && e.clientX <= headerRect.right &&
              e.clientY >= headerRect.top && e.clientY <= headerRect.bottom) ||
             e.clientX < 0 || e.clientY < 0) {
           // Put chip back in pile
           chipCount++;
           chipPileCount.textContent = chipCount;
           chipPile.style.visibility = 'visible';
           if (draggedChip) {
             draggedChip.remove();
           }
         } else {
           // Check if dropped on another chip
           const placedChips = document.querySelectorAll('.placed-chip');
           let targetChip = null;

           for (const otherChip of placedChips) {
             if (otherChip === draggedChip) continue;
             const rect = otherChip.getBoundingClientRect();
             if (e.clientX >= rect.left && e.clientX <= rect.right &&
                 e.clientY >= rect.top && e.clientY <= rect.bottom) {
               targetChip = otherChip;
               break;
             }
           }

           if (targetChip) {
             // Merge chips
             targetChip.textContent = parseInt(targetChip.textContent) +
                                      parseInt(draggedChip.textContent);
             draggedChip.remove();
           } else {
             // Dropped outside header - make it stay
             if (draggedChip) {
               draggedChip.style.pointerEvents = 'auto';
               draggedChip.style.zIndex = '999'; // Below header when placed
               draggedChip.style.cursor = 'grab';
             }
           }
         }

         draggedChip = null;
       };

       document.body.addEventListener('pointermove', onPointerMove);
       document.body.addEventListener('pointerup', onPointerUp);
     }

     // Add pointer event drag functionality to chip pile
     chipPile.addEventListener('pointerdown', (e) => {
       if (chipCount <= 0) return;

       e.preventDefault();

       if (draggedChip != null) return;

       // Determine chip value based on Shift key
       const chipsToPlace = Math.min(chipCount, e.shiftKey ? rewardMultiplier : 1);

       // Decrement chip count
       chipCount -= chipsToPlace;
       chipPileCount.textContent = chipCount;

       // Create dragging chip
       const chip = document.createElement('div');
       chip.className = 'chip placed-chip red';
       chip.textContent = chipsToPlace;
       chip.style.left = (e.pageX - 20) + 'px';
       chip.style.top = (e.pageY - 20) + 'px';

       chip.addEventListener('pointerdown', (e) => {
         e.stopPropagation();
         startDragging(chip, false, e);
       });

       document.body.appendChild(chip);

       startDragging(chip, true, e);
     });

     async function displayRevision() {
       let contentHtml;

       if (currentRevisionIndex === 0) {
         contentHtml = revisionHtml[0];
       } else {
         const oldHtml = revisionHtml[currentRevisionIndex - 1];
         const newHtml = revisionHtml[currentRevisionIndex];
         contentHtml = htmldiff.execute(oldHtml, newHtml);
       }

       const currentRev = allRevisions[currentRevisionIndex];
       const revisionDate = currentRev ? new Date(currentRev.timestamp).toLocaleString() : 'N/A';
       const articleUrl = `https://en.wikipedia.org/wiki/${encodeURIComponent(pageTitle)}`;

       headerInfo.innerHTML = `
         <div>Article: <a href="${articleUrl}" target="_blank" rel="noopener noreferrer">${pageTitle}</a></div>
         <div>Showing revision ${currentRevisionIndex + 1} of ${allRevisions.length}</div>
         <div>${revisionDate}</div>
       `;
       content.innerHTML = contentHtml;

       // Check if this revision has any changes (ins or del elements)
       const hasChanges = currentRevisionIndex === 0 ||
                          content.querySelector('ins, del') !== null;

       // If no changes and not the last revision, skip to next immediately
       if (!hasChanges && currentRevisionIndex < allRevisions.length - 1) {
         nextRevision();
         return;
       }

       await scoreRound();

       // Check if we're on the last revision - end the game
       if (currentRevisionIndex >= allRevisions.length - 1) {
         countdown.textContent = '';
         clearInterval(countdownInterval);
         showEndGameScreen();
         return;
       }

       // Start countdown (only if not game over)
       if (chipCount > 0) {
         clearInterval(countdownInterval);
         let count = countdownTime;
         countdown.textContent = count;

         countdownInterval = setInterval(() => {
           if (isGameEnded || isPaused) { return; }

           count--;
           if (count > 0) {
             countdown.textContent = count;
             // Play countdown sound when hitting 3
             if (count === 3) {
               playSound(countdownBuffer, 0.5);
             }
             // Create particles for countdown 3, 2, 1
             if (count <= 3) {
               createCountdownParticles(count);
             }
           } else {
             countdown.textContent = count;
             createCountdownParticles(0);
             clearInterval(countdownInterval);
             setTimeout(() => {
               nextRevision();
             }, 100);
           }
         }, 1000);
       } else {
         countdown.textContent = '';
       }
     }

     async function nextRevision() {
       if (currentRevisionIndex >= allRevisions.length - 1) return;

       currentRevisionIndex++;

       // Fetch content if we don't have it yet
       if (!revisionHtml[currentRevisionIndex]) {
         const revId = allRevisions[currentRevisionIndex].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${revId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[currentRevisionIndex] = contentData.parse.text['*'];
       }

       displayRevision();
     }

     async function fetchRandomArticleEdits() {
       const headers = {
         'User-Agent': 'MediaWiki REST API docs examples/0.1 (https://meta.wikimedia.org/wiki/User:APaskulin_(WMF))'
       };

       try {
         // First, get a random Wikipedia article
         const randomUrl = 'https://en.wikipedia.org/w/api.php?action=query&list=random&rnnamespace=0&rnlimit=1&format=json&origin=*';
         const randomResponse = await fetch(randomUrl);
         const randomData = await randomResponse.json();
         pageTitle = randomData.query.random[0].title;

         headerInfo.innerHTML = `Loading edits for: ${pageTitle}...`;

         // Fetch all revisions (up to 1000 with pagination)
         let continueToken = null;

         while (allRevisions.length < 1000) {
           const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(pageTitle)}&prop=revisions&rvlimit=500&rvdir=newer&format=json&origin=*${continueToken ? '&rvcontinue=' + continueToken : ''}`;
           const historyResponse = await fetch(historyUrl);
           const historyData = await historyResponse.json();
           const page = historyData.query.pages[Object.keys(historyData.query.pages)[0]];

           if (page.revisions) {
             allRevisions = allRevisions.concat(page.revisions);
           }

           if (historyData.continue && historyData.continue.rvcontinue && allRevisions.length < 1000) {
             continueToken = historyData.continue.rvcontinue;
           } else {
             break;
           }
         }

         // Get the original article HTML (first revision)
         const firstRevId = allRevisions[0].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${firstRevId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[0] = contentData.parse.text['*'];

         displayRevision();
       } catch (error) {
         headerInfo.innerHTML = 'Error loading data: ' + error.message;
       }
     }

     // Start screen logic
     async function checkArticleEdits(articleName) {
       try {
         articleInfo.textContent = 'Checking article...';
         startGameBtn.disabled = true;

         const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=1&format=json&origin=*`;
         const response = await fetch(historyUrl);
         const data = await response.json();
         const pages = data.query.pages;
         const pageId = Object.keys(pages)[0];

         if (pageId === '-1') {
           articleInfo.textContent = 'Article not found. Please try another.';
           selectedArticle = null;
           updateShareUrl();
           return;
         }

         // Fetch revision count
         const countUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=500&format=json&origin=*`;
         const countResponse = await fetch(countUrl);
         const countData = await countResponse.json();
         const page = countData.query.pages[Object.keys(countData.query.pages)[0]];

         let revCount = 0;
         if (page.revisions) {
           revCount = page.revisions.length;
           // Note: This is approximate since Wikipedia limits to 500 revisions per query
           if (countData.continue) {
             revCount = '500+';
           }
         }

         selectedArticle = articleName;
         articleInfo.textContent = `Found: "${articleName}" with ${revCount} edits`;
         startGameBtn.disabled = false;
         updateShareUrl();
       } catch (error) {
         articleInfo.textContent = 'Error checking article: ' + error.message;
         selectedArticle = null;
         updateShareUrl();
       }
     }

     function updateShareUrl() {
       const chipCountInputValue = chipCountInput.value;
       const countdownInputValue = countdownInput.value;
       const multiplierInputValue = multiplierInput.value;
       if (selectedArticle && chipCountInputValue && countdownInputValue && multiplierInputValue) {
         const params = new URLSearchParams({
           article: selectedArticle,
           chips: chipCountInputValue,
           countdown: countdownInputValue,
           multiplier: multiplierInputValue
         });
         const url = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
         shareUrl.value = url;
       } else {
         shareUrl.value = '';
       }
     }

     async function loadRandomArticle() {
       try {
         randomArticleBtn.disabled = true;
         articleInfo.textContent = 'Loading random article...';

         const randomUrl = 'https://en.wikipedia.org/w/api.php?action=query&list=random&rnnamespace=0&rnlimit=1&format=json&origin=*';
         const response = await fetch(randomUrl);
         const data = await response.json();
         const articleName = data.query.random[0].title;

         articleInput.value = articleName;
         await checkArticleEdits(articleName);
       } catch (error) {
         articleInfo.textContent = 'Error loading random article: ' + error.message;
       } finally {
         randomArticleBtn.disabled = false;
       }
     }

     function startGame() {
       pageTitle = selectedArticle;
       chipCount = parseInt(chipCountInput.value);
       countdownTime = parseInt(countdownInput.value);
       rewardMultiplier = parseInt(multiplierInput.value);
       startingChips = chipCount;
       totalChipsInserted = startingChips;
       totalChipsWon = 0;
       chipPileCount.textContent = chipCount;

       startScreen.classList.add('hidden');
       container.classList.remove('hidden');

       fetchArticleEdits(pageTitle);
     }

     async function fetchArticleEdits(articleName) {
       try {
         headerInfo.innerHTML = `Loading edits for: ${articleName}...`;

         // Fetch all revisions (up to 1000 with pagination)
         allRevisions = [];
         let continueToken = null;

         while (allRevisions.length < 1000) {
           const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=500&rvdir=newer&format=json&origin=*${continueToken ? '&rvcontinue=' + continueToken : ''}`;
           const historyResponse = await fetch(historyUrl);
           const historyData = await historyResponse.json();
           const page = historyData.query.pages[Object.keys(historyData.query.pages)[0]];

           if (page.revisions) {
             allRevisions = allRevisions.concat(page.revisions);
           }

           if (historyData.continue && historyData.continue.rvcontinue && allRevisions.length < 1000) {
             continueToken = historyData.continue.rvcontinue;
           } else {
             break;
           }
         }

         // Get the original article HTML (first revision)
         const firstRevId = allRevisions[0].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${firstRevId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[0] = contentData.parse.text['*'];

         displayRevision();
       } catch (error) {
         headerInfo.innerHTML = 'Error loading data: ' + error.message;
       }
     }

     // Event listener for game over screen
     continueBtn.addEventListener('click', () => {
       const insertChips = parseInt(insertChipsInput.value);
       chipCount += insertChips;
       totalChipsInserted += insertChips;
       chipPileCount.textContent = chipCount;
       gameOverScreen.classList.add('hidden');

       // Restart countdown
       if (currentRevisionIndex < allRevisions.length - 1) {
         clearInterval(countdownInterval);
         let count = countdownTime;
         countdown.textContent = count;

         countdownInterval = setInterval(() => {
           count--;
           if (count > 0) {
             countdown.textContent = count;
             // Play countdown sound when hitting 3
             if (count === 3) {
               playSound(countdownBuffer, 0.5);
             }
             // Create particles for countdown 3, 2, 1
             if (count <= 3) {
               createCountdownParticles(count);
             }
           } else {
             countdown.textContent = count;
             createCountdownParticles(0);
             clearInterval(countdownInterval);
             setTimeout(() => {
               nextRevision();
             }, 100);
           }
         }, 1000);
       }
     });

     // Event listeners for start screen
     articleInput.addEventListener('input', (e) => {
       const value = e.target.value.trim();
       if (value) {
         checkArticleEdits(value);
       } else {
         selectedArticle = null;
         articleInfo.textContent = '';
         startGameBtn.disabled = true;
         updateShareUrl();
       }
     });

     chipCountInput.addEventListener('input', () => {
       updateShareUrl();
     });

     countdownInput.addEventListener('input', () => {
       updateShareUrl();
     });

     multiplierInput.addEventListener('input', () => {
       updateShareUrl();
       const multiplier = multiplierInput.value;
       multiplierText.textContent = `${multiplier}x`;
     });

     randomArticleBtn.addEventListener('click', loadRandomArticle);
     startGameBtn.addEventListener('click', startGame);

     // Copy share URL button
     copyShareUrlBtn.addEventListener('click', async () => {
       const shareUrlValue = shareUrl.value;
       if (shareUrlValue) {
         try {
           await navigator.clipboard.writeText(shareUrlValue);
           const btn = copyShareUrlBtn;
           const originalText = btn.textContent;
           btn.textContent = 'Copied!';
           setTimeout(() => {
             btn.textContent = originalText;
           }, 2000);
         } catch (err) {
           console.error('Failed to copy:', err);
         }
       }
     });

     // Check for URL parameters on load
     const urlParams = new URLSearchParams(window.location.search);
     const articleParam = urlParams.get('article');
     const chipsParam = urlParams.get('chips');
     const countdownParam = urlParams.get('countdown');
     const multiplierParam = urlParams.get('multiplier');

     if (articleParam) {
       articleInput.value = articleParam;
       if (chipsParam) {
         chipCountInput.value = chipsParam;
       }
       if (countdownParam) {
         countdownInput.value = countdownParam;
       }
       if (multiplierParam) {
         multiplierInput.value = multiplierParam;
         multiplierText.textContent = `${multiplierParam}x`;
       }
       checkArticleEdits(articleParam);
     } else {
       // Load a random article on boot if no URL params
       loadRandomArticle();
     }

     // Pause/Resume button
     pauseBtn.addEventListener('click', () => {
       if (isPaused) {
         // Resume
         isPaused = false;
         pauseBtn.textContent = 'Pause';

         // Restart countdown from paused value
         if (currentRevisionIndex < allRevisions.length - 1 && chipCount > 0) {
           clearInterval(countdownInterval);
           let count = pausedCountdown;
           countdown.textContent = count;

           countdownInterval = setInterval(() => {
             count--;
             if (count > 0) {
               countdown.textContent = count;
               // Play countdown sound when hitting 3
               if (count === 3) {
                 playSound(countdownBuffer, 0.5);
               }
               // Create particles for countdown 3, 2, 1
               if (count <= 3) {
                 createCountdownParticles(count);
               }
             } else {
               countdown.textContent = count;
               createCountdownParticles(0);
               clearInterval(countdownInterval);
               setTimeout(() => {
                 nextRevision();
               }, 100);
             }
           }, 1000);
         }
       } else {
         // Pause
         isPaused = true;
         pauseBtn.textContent = 'Resume';
         pausedCountdown = parseInt(countdown.textContent) || 0;
         clearInterval(countdownInterval);
         stopAllSounds();
       }
     });

     // Shared function to clear all placed chips
     function clearAllBets() {
       document.querySelectorAll('.placed-chip').forEach(chip => {
         const chipValue = parseInt(chip.textContent);
         chipCount += chipValue;
         chip.remove();
       });
       chipCount.textContent = chipCount;
     }

     // Shared function to show end game screen
     function showEndGameScreen() {
       isGameEnded = true;

       clearInterval(countdownInterval);
       stopAllSounds();
       clearAllBets();

       // Get current revision info
       const currentRev = allRevisions[currentRevisionIndex];
       const revisionDate = currentRev ? new Date(currentRev.timestamp).toLocaleString() : 'N/A';

       // Calculate stats
       const netGain = chipCount - totalChipsInserted;

       // Populate end game screen
       endArticle.textContent = pageTitle;
       endRevision.textContent = `${currentRevisionIndex + 1} of ${allRevisions.length}`;
       endRevisionDate.textContent = revisionDate;
       endChipsInserted.textContent = totalChipsInserted;
       endChipsWon.textContent = totalChipsWon;
       endCurrentChips.textContent = chipCount;
       endNetGain.textContent = netGain >= 0 ? `+${netGain}` : netGain;
       endNetGain.style.color = netGain >= 0 ? 'green' : 'red';

       // Hide other screens and show end game screen
       gameOverScreen.classList.add('hidden');
       endGameScreen.classList.remove('hidden');
     }

     // Clear all bets button
     clearBetsBtn.addEventListener('click', clearAllBets);

     // End Game button
     endGameBtn.addEventListener('click', showEndGameScreen);

     // End game from game over screen
     endGameFromOverBtn.addEventListener('click', showEndGameScreen);

     // Return to Start button
     returnToStartBtn.addEventListener('click', () => {
       endGameScreen.classList.add('hidden');
       container.classList.add('hidden');
       startScreen.classList.remove('hidden');
       gameOverScreen.classList.add('hidden');

       // Reset game state
       allRevisions = [];
       revisionHtml = [];
       currentRevisionIndex = 0;
       isPaused = false;
       pausedCountdown = 0;
       totalChipsInserted = 0;
       totalChipsWon = 0;
       pauseBtn.textContent = 'Pause';

       // Clear placed chips and content
       document.querySelectorAll('.placed-chip').forEach(chip => chip.remove());
       content.innerHTML = '';
     });
    </script>
  </body>
</html>
