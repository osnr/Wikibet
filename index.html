<html>
  <head>
    <style>
     body, html {
         margin: 0;
         padding: 0;
     }
     #header {
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         background-color: rgba(255, 255, 255, 0.9);
         border-bottom: 1px solid #ccc;
         padding: 10px;
         z-index: 1000;
         display: flex;
         justify-content: space-between;
         align-items: start;
         font-family: system-ui;
     }
     #countdown {
         font-size: 48px;
         font-weight: bold;
         color: #a95226;
     }
     #gameControls {
         position: absolute;
         gap: 10px;
         right: 4em;
         top: 1.25em;
     }
     #gameControls button {
         padding: 8px 16px;
         font-size: 14px;
         border-radius: 5px;
         border: 1px solid #ccc;
         background-color: white;
         cursor: pointer;
     }
     #gameControls button:hover {
         background-color: #f0f0f0;
     }
     #chipTray {
         position: absolute;
         left: 50%;
         transform: translateX(-50%);
         display: flex;
         gap: 10px;
         align-items: center;
     }
     .chip {
         width: 40px;
         height: 40px;
         border-radius: 50%;
         border: 3px solid white;
         display: flex;
         align-items: center;
         justify-content: center;
         font-family: serif;
         font-weight: bold;
         color: white;
         cursor: grab;
         box-shadow: 0 2px 4px rgba(0,0,0,0.3);
     }
     .chip:active {
         cursor: grabbing;
     }
     .chip.red { background-color: #dc3545; }
     .placed-chip {
         position: absolute;
         cursor: grab;
         z-index: 999;
     }
     .ghost-chip {
         position: absolute;
         pointer-events: none;
         opacity: 0.4;
         z-index: 998;
     }
     #chipPile {
         position: relative;
     }
     #chipCount {
         font-size: 24px;
     }
     #content {
         margin-top: 120px;
         padding: 1em;
         user-select: none;
         -webkit-user-select: none;
     }
     ins { background-color: #90EE90; text-decoration: none; }
     del { background-color: #FFB6C1; }

     #startScreen {
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         min-height: 100vh;
         gap: 20px;
         padding: 20px;
         box-sizing: border-box;
     }
     #startScreen h1 {
         margin: 0 0 20px 0;
     }
     #startScreen input, #startScreen button {
         padding: 10px 15px;
         font-size: 16px;
         border-radius: 5px;
         border: 1px solid #ccc;
     }
     #startScreen input {
         width: 300px;
     }
     #startScreen button {
         background-color: #007bff;
         color: white;
         border: none;
         cursor: pointer;
     }
     #startScreen button:hover {
         background-color: #0056b3;
     }
     #startScreen button:disabled {
         background-color: #ccc;
         cursor: not-allowed;
     }
     .inputGroup {
         display: flex;
         flex-direction: column;
         gap: 10px;
         width: 300px;
         border-radius: 10px;
     }
     .inputGroup label {
         font-weight: bold;
     }
     #articleInfo {
         color: #666;
         font-style: italic;
     }
     #shareUrl {
         width: 400px;
         font-size: 14px;
         background-color: #f5f5f5;
     }
     .shareUrlContainer {
         display: flex;
         gap: 10px;
         align-items: center;
     }
     #copyShareUrlBtn {
         padding: 8px 16px;
         font-size: 14px;
         border-radius: 5px;
         border: 1px solid #ccc;
         background-color: white;
         cursor: pointer;
     }
     #copyShareUrlBtn:hover {
         background-color: #f0f0f0;
     }
     .hidden {
         display: none !important;
     }
     #gameOverScreen {
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         bottom: 0;
         background-color: rgba(0, 0, 0, 0.8);
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         z-index: 2000;
         gap: 20px;
     }
     #gameOverScreen h2 {
         color: white;
         font-size: 48px;
         margin: 0;
     }
     #gameOverScreen .inputGroup {
         background-color: white;
         padding: 20px;
     }
     #gameOverScreen button {
         padding: 15px 30px;
         font-size: 18px;
         background-color: #28a745;
         color: white;
         border: none;
         border-radius: 5px;
         cursor: pointer;
     }
     #gameOverScreen button:hover {
         background-color: #218838;
     }
     #gameOverScreen #endGameFromOverBtn {
         background-color: #dc3545;
     }
     #gameOverScreen #endGameFromOverBtn:hover {
         background-color: #c82333;
     }
     #endGameScreen {
         position: fixed;
         top: 0;
         left: 0;
         right: 0;
         bottom: 0;
         background-color: rgba(0, 0, 0, 0.8);
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: center;
         z-index: 2000;
         gap: 20px;
     }
     #endGameScreen h2 {
         color: white;
         font-size: 48px;
         margin: 0;
     }
     #endGameScreen .stats {
         background-color: white;
         padding: 30px;
         border-radius: 10px;
         font-size: 18px;
     }
     #endGameScreen .stats div {
         margin: 10px 0;
     }
     #endGameScreen .stats div:last-child {
         font-size: 30px;
     }
     #endGameScreen button {
         padding: 15px 30px;
         font-size: 18px;
         background-color: #007bff;
         color: white;
         border: none;
         border-radius: 5px;
         cursor: pointer;
     }
     #endGameScreen button:hover {
         background-color: #0056b3;
     }
    </style>
  </head>
  <body>
    <div id="gameOverScreen" class="hidden">
      <h2>Out of chips!</h2>
      <div class="inputGroup">
        <label for="insertChipsInput">Insert chips to continue:</label>
        <input type="number" id="insertChipsInput" value="5" min="1" max="20">
      </div>
      <button id="continueBtn">Continue</button>
      <button id="endGameFromOverBtn">End game</button>
    </div>

    <div id="endGameScreen" class="hidden">
      <h2>Game summary</h2>
      <div class="stats">
        <div><strong>Article:</strong> <span id="endArticle"></span></div>
        <div><strong>Current revision:</strong> <span id="endRevision"></span></div>
        <div><strong>Revision date:</strong> <span id="endRevisionDate"></span></div>
        <hr>
        <div><strong>Total chips inserted:</strong> <span id="endChipsInserted"></span></div>
        <div><strong>Total chips won:</strong> <span id="endChipsWon"></span></div>
        <div><strong>Current chips:</strong> <span id="endCurrentChips"></span></div>
        <div><strong>Net gain/loss:</strong> <span id="endNetGain"></span></div>
      </div>
      <button id="returnToStartBtn">Return to start</button>
    </div>

    <div id="startScreen">
      <h1>WikiEditBet</h1>

      <div>
        <p>Click on the article to place chips to bet on where you think edits
          will happen in the next round.</p>
        <p>Every round, when an edit touches a chip, you'll 5x its value.
          When no edits touch a chip, you'll lose it.</p>
      </div>

      <div class="inputGroup">
        <label for="articleInput">Article name:</label>
        <input type="text" id="articleInput" placeholder="Enter article name (e.g., Apple Inc.)">
        <button id="randomArticleBtn">Random article</button>
      </div>

      <div id="articleInfo"></div>

      <div class="inputGroup">
        <label for="chipCountInput">Starting chips:</label>
        <input type="number" id="chipCountInput" value="15" min="1" max="20">
      </div>

      <div class="inputGroup">
        <label for="countdownInput">Round time (seconds):</label>
        <input type="number" id="countdownInput" value="4" min="1" max="30">
      </div>

      <div class="inputGroup">
        <label for="shareUrl">Share this URL to play this exact game:</label>
        <div class="shareUrlContainer">
          <input type="text" id="shareUrl" readonly>
          <button id="copyShareUrlBtn">Copy</button>
        </div>
      </div>

      <button id="startGameBtn" disabled>Start game</button>
    </div>

    <div id="container" class="hidden">
      <div id="header">
        <div id="headerInfo">
        </div>
        <div id="chipTray">
          <div id="chipPile" class="chip red">
            <span id="chipCount">15</span>
          </div>
        </div>
        <div id="gameControls">
          <button id="clearBetsBtn">Clear all bets</button>
          <button id="endGameBtn">End game</button>
          <button id="pauseBtn">Pause</button>
        </div>
        <div id="countdown">4</div>
      </div>

      <div id="content"></div>
    </div>

    <script>
     // Polyfill for CommonJS module.exports in browser
     var module = { exports: {} };
    </script>
    <script src="vendor/htmldiff.js"></script>
    <script>
     const htmldiff = module.exports.default;

     let allRevisions = [];
     let revisionHtml = [];
     let currentRevisionIndex = 0;
     let pageTitle = '';
     let countdownInterval = null;
     let draggedChip = null;
     let chipCount = 15;
     let selectedArticle = null;
     let countdownTime = 4;
     let isPaused = false;
     let pausedCountdown = 0;
     let totalChipsInserted = 0;
     let totalChipsWon = 0;
     let startingChips = 5;

     // Web Audio API setup for concurrent sound effects
     const audioCtx = new AudioContext();
     let coinBuffer = null;
     let hurtBuffer = null;
     let selectBuffer = null;

     // Load audio buffers
     async function loadAudioBuffers() {
       try {
         const [coinResp, hurtResp, selectResp] = await Promise.all([
           fetch('res/coin.wav'),
           fetch('res/hurt.wav'),
           fetch('res/select.wav')
         ]);
         const [coinArrayBuffer, hurtArrayBuffer, selectArrayBuffer] = await Promise.all([
           coinResp.arrayBuffer(),
           hurtResp.arrayBuffer(),
           selectResp.arrayBuffer()
         ]);
         [coinBuffer, hurtBuffer, selectBuffer] = await Promise.all([
           audioCtx.decodeAudioData(coinArrayBuffer),
           audioCtx.decodeAudioData(hurtArrayBuffer),
           audioCtx.decodeAudioData(selectArrayBuffer)
         ]);
       } catch (e) {
         console.log('Failed to load audio:', e);
       }
     }

     // Play sound using AudioBuffer
     function playSound(buffer) {
       if (!buffer) return;
       const source = audioCtx.createBufferSource();
       source.buffer = buffer;
       source.connect(audioCtx.destination);
       source.start();
     }

     // Load audio on startup
     loadAudioBuffers();

     async function scoreRound() {
       // Check placed chips after content is rendered
       if (currentRevisionIndex == 0) {
         return;
       }

       const placedChips = Array.from(document.querySelectorAll('.placed-chip'));

       for (let i = 0; i < placedChips.length; i++) {
         const chip = placedChips[i];

         // Scroll chip into view if needed
         const headerHeight = document.getElementById('header').offsetHeight;
         chip.scrollIntoView({ behavior: 'smooth', block: 'center' });

         const chipRect = chip.getBoundingClientRect();

         // Check if chip intersects with any ins or del element
         let isOnChange = false;
         const changes = document.querySelectorAll('ins, del');
         for (const change of changes) {
           const changeRect = change.getBoundingClientRect();

           // Check if rectangles intersect
           if (!(chipRect.right < changeRect.left ||
                 chipRect.left > changeRect.right ||
                 chipRect.bottom < changeRect.top ||
                 chipRect.top > changeRect.bottom)) {
             isOnChange = true;
             break;
           }
         }

         // Get chip value
         const chipValue = parseInt(chip.textContent);

         // Play sound effect
         playSound(isOnChange ? coinBuffer : hurtBuffer);

         // Create overlay animation
         const overlay = document.createElement('div');
         overlay.textContent = isOnChange ? `+${chipValue * 5}` : `-${chipValue}`;
         overlay.style.position = 'absolute';
         overlay.style.left = chip.style.left;
         overlay.style.top = chip.style.top;
         overlay.style.fontSize = '24px';
         overlay.style.fontWeight = 'bold';
         overlay.style.color = isOnChange ? 'green' : 'red';
         overlay.style.zIndex = '1002';
         overlay.style.pointerEvents = 'none';
         overlay.style.transition = 'opacity 2s, transform 2s';
         overlay.style.transform = 'translateY(0)';
         document.body.appendChild(overlay);

         // Animate and remove
         setTimeout(() => {
           overlay.style.opacity = '0';
           overlay.style.transform = 'translateY(-20px)';
         }, 0);

         setTimeout(() => {
           overlay.remove();
         }, 2000);

         // Update chip count and remove chip
         if (isOnChange) {
           const chipsWon = chipValue * 5;
           chipCount += chipsWon;
           totalChipsWon += chipsWon - chipValue;
         }
         chip.remove();

         document.getElementById('chipCount').textContent = chipCount;

         // Wait 300ms before next chip
         if (i < placedChips.length - 1) {
           await new Promise(resolve => setTimeout(resolve, 300));
         }
       }

       // Check if game over
       if (chipCount === 0) {
         clearInterval(countdownInterval);
         document.getElementById('gameOverScreen').classList.remove('hidden');
       }
     }

     // Create ghost chip
     let ghostChip = null;
     function createGhostChip() {
       if (!ghostChip) {
         ghostChip = document.createElement('div');
         ghostChip.className = 'chip ghost-chip red';
         ghostChip.style.display = 'none';
         document.body.appendChild(ghostChip);
       }
       return ghostChip;
     }
     createGhostChip();

     // Track if mouse is over content and last position
     let isOverContent = false;
     let lastMouseX = 0;
     let lastMouseY = 0;
     let lastShiftState = false;

     function updateGhostChip(shiftKey) {
       if (!isOverContent || chipCount <= 0 || draggedChip != null) {
         ghostChip.style.display = 'none';
         return;
       }

       const chipValue = shiftKey ? Math.min(5, chipCount) : 1;
       ghostChip.textContent = chipValue;
       ghostChip.style.display = 'flex';
       ghostChip.style.left = (lastMouseX - 20) + 'px';
       ghostChip.style.top = (lastMouseY - 20) + 'px';
     }

     // Show/hide ghost chip on content hover
     content.addEventListener('pointermove', (e) => {
       lastMouseX = e.pageX;
       lastMouseY = e.pageY;
       isOverContent = true;

       if (chipCount <= 0 || draggedChip != null) {
         ghostChip.style.display = 'none';
         return;
       }

       // Check if hovering over an existing chip
       if (e.target.classList.contains('placed-chip') || e.target.closest('.placed-chip')) {
         ghostChip.style.display = 'none';
         isOverContent = false;
         return;
       }

       lastShiftState = e.shiftKey;
       updateGhostChip(e.shiftKey);
     });

     content.addEventListener('pointerleave', () => {
       isOverContent = false;
       ghostChip.style.display = 'none';
     });

     // Update ghost chip on Shift key press/release
     document.addEventListener('keydown', (e) => {
       if (e.key === 'Shift' && lastShiftState !== true) {
         lastShiftState = true;
         updateGhostChip(true);
       }
     });

     document.addEventListener('keyup', (e) => {
       if (e.key === 'Shift' && lastShiftState !== false) {
         lastShiftState = false;
         updateGhostChip(false);
       }
     });

     // Click on content to place chip
     content.addEventListener('pointerdown', (e) => {
       if (chipCount <= 0) return;
       if (draggedChip != null) return;

       // Check if we clicked on an existing placed chip or inside one
       if (e.target.classList.contains('placed-chip') || e.target.closest('.placed-chip')) {
         return; // Let the chip's own handler deal with it
       }

       // Prevent default behavior (especially text selection on Shift-click)
       e.preventDefault();

       // Determine chip value based on Shift key
       const chipsToPlace = e.shiftKey ? Math.min(5, chipCount) : 1;

       // Decrement chip count
       chipCount -= chipsToPlace;
       document.getElementById('chipCount').textContent = chipCount;

       // Create chip at click location
       const chip = document.createElement('div');
       chip.className = 'chip placed-chip red';
       chip.textContent = chipsToPlace;
       chip.style.left = (e.pageX - 20) + 'px';
       chip.style.top = (e.pageY - 20) + 'px';
       chip.style.cursor = 'grab';

       chip.addEventListener('pointerdown', (e) => {
         e.stopPropagation();
         startDragging(chip, false, e);
       });

       document.body.appendChild(chip);
     });

     // Shared drag logic
     function startDragging(chip, fromPile, e) {
       e.preventDefault();
       e.stopPropagation();

       if (draggedChip != null) return;

       draggedChip = chip;
       draggedChip.style.zIndex = '1001'; // Above header while dragging
       document.body.style.cursor = 'grabbing';

       // Capture pointer to ensure we get all move events
       e.target.setPointerCapture(e.pointerId);

       let hasMoved = false;
       const startX = e.pageX;
       const startY = e.pageY;
       const isShiftKey = e.shiftKey;

       const onPointerMove = (e) => {
         if (draggedChip) {
           draggedChip.style.left = (e.pageX - 20) + 'px';
           draggedChip.style.top = (e.pageY - 20) + 'px';

           // Check if moved more than a few pixels
           if (Math.abs(e.pageX - startX) > 5 || Math.abs(e.pageY - startY) > 5) {
             hasMoved = true;
           }
         }
       };

       const onPointerUp = (e) => {
         document.body.removeEventListener('pointermove', onPointerMove);
         document.body.removeEventListener('pointerup', onPointerUp);
         document.body.style.cursor = '';

         // Check if clicked on an existing placed chip (not moved)
         if (!hasMoved && !fromPile) {
           const incrementAmount = Math.min(chipCount, isShiftKey ? 5 : 1);
           draggedChip.textContent = parseInt(draggedChip.textContent) + incrementAmount;
           chipCount -= incrementAmount;
           document.getElementById('chipCount').textContent = chipCount;
           draggedChip = null;
           return;
         }

         // Check if pointer is inside header
         const header = document.getElementById('header');
         const headerRect = header.getBoundingClientRect();
         if ((e.clientX >= headerRect.left && e.clientX <= headerRect.right &&
              e.clientY >= headerRect.top && e.clientY <= headerRect.bottom) ||
             e.clientX < 0 || e.clientY < 0) {
           // Put chip back in pile
           chipCount++;
           document.getElementById('chipCount').textContent = chipCount;
           chipPile.style.visibility = 'visible';
           if (draggedChip) {
             draggedChip.remove();
           }
         } else {
           // Check if dropped on another chip
           const placedChips = document.querySelectorAll('.placed-chip');
           let targetChip = null;

           for (const otherChip of placedChips) {
             if (otherChip === draggedChip) continue;
             const rect = otherChip.getBoundingClientRect();
             if (e.clientX >= rect.left && e.clientX <= rect.right &&
                 e.clientY >= rect.top && e.clientY <= rect.bottom) {
               targetChip = otherChip;
               break;
             }
           }

           if (targetChip) {
             // Merge chips
             targetChip.textContent = parseInt(targetChip.textContent) +
                                      parseInt(draggedChip.textContent);
             draggedChip.remove();
           } else {
             // Dropped outside header - make it stay
             if (draggedChip) {
               draggedChip.style.pointerEvents = 'auto';
               draggedChip.style.zIndex = '999'; // Below header when placed
               draggedChip.style.cursor = 'grab';
             }
           }
         }

         draggedChip = null;
       };

       document.body.addEventListener('pointermove', onPointerMove);
       document.body.addEventListener('pointerup', onPointerUp);
     }

     // Add pointer event drag functionality to chip pile
     chipPile.addEventListener('pointerdown', (e) => {
       if (chipCount <= 0) return;

       e.preventDefault();

       if (draggedChip != null) return;

       // Determine chip value based on Shift key
       const chipsToPlace = Math.min(chipCount, e.shiftKey ? 5 : 1);

       // Decrement chip count
       chipCount -= chipsToPlace;
       document.getElementById('chipCount').textContent = chipCount;

       // Create dragging chip
       const chip = document.createElement('div');
       chip.className = 'chip placed-chip red';
       chip.textContent = chipsToPlace;
       chip.style.left = (e.pageX - 20) + 'px';
       chip.style.top = (e.pageY - 20) + 'px';

       chip.addEventListener('pointerdown', (e) => {
         e.stopPropagation();
         startDragging(chip, false, e);
       });

       document.body.appendChild(chip);

       startDragging(chip, true, e);
     });

     async function displayRevision() {
       let contentHtml;

       if (currentRevisionIndex === 0) {
         contentHtml = revisionHtml[0];
       } else {
         const oldHtml = revisionHtml[currentRevisionIndex - 1];
         const newHtml = revisionHtml[currentRevisionIndex];
         contentHtml = htmldiff.execute(oldHtml, newHtml);
       }

       const currentRev = allRevisions[currentRevisionIndex];
       const revisionDate = currentRev ? new Date(currentRev.timestamp).toLocaleString() : 'N/A';
       const articleUrl = `https://en.wikipedia.org/wiki/${encodeURIComponent(pageTitle)}`;

       headerInfo.innerHTML = `
         <div>Article: <a href="${articleUrl}" target="_blank" rel="noopener noreferrer">${pageTitle}</a></div>
         <div>Showing revision ${currentRevisionIndex + 1} of ${allRevisions.length}</div>
         <div>${revisionDate}</div>
       `;
       content.innerHTML = contentHtml;

       await scoreRound();

       // Start countdown (only if not game over)
       if (currentRevisionIndex < allRevisions.length - 1 && chipCount > 0) {
         clearInterval(countdownInterval);
         let count = countdownTime;
         document.getElementById('countdown').textContent = count;

         countdownInterval = setInterval(() => {
           count--;
           if (count > 0) {
             document.getElementById('countdown').textContent = count;
           } else {
             clearInterval(countdownInterval);
             nextRevision();
           }
         }, 1000);
       } else {
         document.getElementById('countdown').textContent = '';
       }
     }

     async function nextRevision() {
       if (currentRevisionIndex >= allRevisions.length - 1) return;

       currentRevisionIndex++;

       // Fetch content if we don't have it yet
       if (!revisionHtml[currentRevisionIndex]) {
         const revId = allRevisions[currentRevisionIndex].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${revId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[currentRevisionIndex] = contentData.parse.text['*'];
       }

       displayRevision();
     }

     async function fetchRandomArticleEdits() {
       const headers = {
         'User-Agent': 'MediaWiki REST API docs examples/0.1 (https://meta.wikimedia.org/wiki/User:APaskulin_(WMF))'
       };

       try {
         // First, get a random Wikipedia article
         const randomUrl = 'https://en.wikipedia.org/w/api.php?action=query&list=random&rnnamespace=0&rnlimit=1&format=json&origin=*';
         const randomResponse = await fetch(randomUrl);
         const randomData = await randomResponse.json();
         pageTitle = randomData.query.random[0].title;

         headerInfo.innerHTML = `Loading edits for: ${pageTitle}...`;

         // Fetch all revisions (up to 1000 with pagination)
         let continueToken = null;

         while (allRevisions.length < 1000) {
           const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(pageTitle)}&prop=revisions&rvlimit=500&rvdir=newer&format=json&origin=*${continueToken ? '&rvcontinue=' + continueToken : ''}`;
           const historyResponse = await fetch(historyUrl);
           const historyData = await historyResponse.json();
           const page = historyData.query.pages[Object.keys(historyData.query.pages)[0]];

           if (page.revisions) {
             allRevisions = allRevisions.concat(page.revisions);
           }

           if (historyData.continue && historyData.continue.rvcontinue && allRevisions.length < 1000) {
             continueToken = historyData.continue.rvcontinue;
           } else {
             break;
           }
         }

         // Get the original article HTML (first revision)
         const firstRevId = allRevisions[0].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${firstRevId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[0] = contentData.parse.text['*'];

         displayRevision();
       } catch (error) {
         headerInfo.innerHTML = 'Error loading data: ' + error.message;
       }
     }

     // Start screen logic
     async function checkArticleEdits(articleName) {
       try {
         document.getElementById('articleInfo').textContent = 'Checking article...';
         document.getElementById('startGameBtn').disabled = true;

         const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=1&format=json&origin=*`;
         const response = await fetch(historyUrl);
         const data = await response.json();
         const pages = data.query.pages;
         const pageId = Object.keys(pages)[0];

         if (pageId === '-1') {
           document.getElementById('articleInfo').textContent = 'Article not found. Please try another.';
           selectedArticle = null;
           updateShareUrl();
           return;
         }

         // Fetch revision count
         const countUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=500&format=json&origin=*`;
         const countResponse = await fetch(countUrl);
         const countData = await countResponse.json();
         const page = countData.query.pages[Object.keys(countData.query.pages)[0]];

         let revCount = 0;
         if (page.revisions) {
           revCount = page.revisions.length;
           // Note: This is approximate since Wikipedia limits to 500 revisions per query
           if (countData.continue) {
             revCount = '500+';
           }
         }

         selectedArticle = articleName;
         document.getElementById('articleInfo').textContent = `Found: "${articleName}" with ${revCount} edits`;
         document.getElementById('startGameBtn').disabled = false;
         updateShareUrl();
       } catch (error) {
         document.getElementById('articleInfo').textContent = 'Error checking article: ' + error.message;
         selectedArticle = null;
         updateShareUrl();
       }
     }

     function updateShareUrl() {
       const chipCountInput = document.getElementById('chipCountInput').value;
       const countdownInput = document.getElementById('countdownInput').value;
       if (selectedArticle && chipCountInput && countdownInput) {
         const params = new URLSearchParams({
           article: selectedArticle,
           chips: chipCountInput,
           countdown: countdownInput
         });
         const url = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
         document.getElementById('shareUrl').value = url;
       } else {
         document.getElementById('shareUrl').value = '';
       }
     }

     async function loadRandomArticle() {
       try {
         document.getElementById('randomArticleBtn').disabled = true;
         document.getElementById('articleInfo').textContent = 'Loading random article...';

         const randomUrl = 'https://en.wikipedia.org/w/api.php?action=query&list=random&rnnamespace=0&rnlimit=1&format=json&origin=*';
         const response = await fetch(randomUrl);
         const data = await response.json();
         const articleName = data.query.random[0].title;

         document.getElementById('articleInput').value = articleName;
         await checkArticleEdits(articleName);
       } catch (error) {
         document.getElementById('articleInfo').textContent = 'Error loading random article: ' + error.message;
       } finally {
         document.getElementById('randomArticleBtn').disabled = false;
       }
     }

     function startGame() {
       pageTitle = selectedArticle;
       chipCount = parseInt(document.getElementById('chipCountInput').value);
       countdownTime = parseInt(document.getElementById('countdownInput').value);
       startingChips = chipCount;
       totalChipsInserted = startingChips;
       totalChipsWon = 0;
       document.getElementById('chipCount').textContent = chipCount;

       document.getElementById('startScreen').classList.add('hidden');
       document.getElementById('container').classList.remove('hidden');

       fetchArticleEdits(pageTitle);
     }

     async function fetchArticleEdits(articleName) {
       try {
         headerInfo.innerHTML = `Loading edits for: ${articleName}...`;

         // Fetch all revisions (up to 1000 with pagination)
         allRevisions = [];
         let continueToken = null;

         while (allRevisions.length < 1000) {
           const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=500&rvdir=newer&format=json&origin=*${continueToken ? '&rvcontinue=' + continueToken : ''}`;
           const historyResponse = await fetch(historyUrl);
           const historyData = await historyResponse.json();
           const page = historyData.query.pages[Object.keys(historyData.query.pages)[0]];

           if (page.revisions) {
             allRevisions = allRevisions.concat(page.revisions);
           }

           if (historyData.continue && historyData.continue.rvcontinue && allRevisions.length < 1000) {
             continueToken = historyData.continue.rvcontinue;
           } else {
             break;
           }
         }

         // Get the original article HTML (first revision)
         const firstRevId = allRevisions[0].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${firstRevId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[0] = contentData.parse.text['*'];

         displayRevision();
       } catch (error) {
         headerInfo.innerHTML = 'Error loading data: ' + error.message;
       }
     }

     // Event listener for game over screen
     document.getElementById('continueBtn').addEventListener('click', () => {
       const insertChips = parseInt(document.getElementById('insertChipsInput').value);
       chipCount += insertChips;
       totalChipsInserted += insertChips;
       document.getElementById('chipCount').textContent = chipCount;
       document.getElementById('gameOverScreen').classList.add('hidden');

       // Restart countdown
       if (currentRevisionIndex < allRevisions.length - 1) {
         clearInterval(countdownInterval);
         let count = countdownTime;
         document.getElementById('countdown').textContent = count;

         countdownInterval = setInterval(() => {
           count--;
           if (count > 0) {
             document.getElementById('countdown').textContent = count;
           } else {
             clearInterval(countdownInterval);
             nextRevision();
           }
         }, 1000);
       }
     });

     // Event listeners for start screen
     document.getElementById('articleInput').addEventListener('input', (e) => {
       const value = e.target.value.trim();
       if (value) {
         checkArticleEdits(value);
       } else {
         selectedArticle = null;
         document.getElementById('articleInfo').textContent = '';
         document.getElementById('startGameBtn').disabled = true;
         updateShareUrl();
       }
     });

     document.getElementById('chipCountInput').addEventListener('input', () => {
       updateShareUrl();
     });

     document.getElementById('countdownInput').addEventListener('input', () => {
       updateShareUrl();
     });

     document.getElementById('randomArticleBtn').addEventListener('click', loadRandomArticle);
     document.getElementById('startGameBtn').addEventListener('click', startGame);

     // Copy share URL button
     document.getElementById('copyShareUrlBtn').addEventListener('click', async () => {
       const shareUrl = document.getElementById('shareUrl').value;
       if (shareUrl) {
         try {
           await navigator.clipboard.writeText(shareUrl);
           const btn = document.getElementById('copyShareUrlBtn');
           const originalText = btn.textContent;
           btn.textContent = 'Copied!';
           setTimeout(() => {
             btn.textContent = originalText;
           }, 2000);
         } catch (err) {
           console.error('Failed to copy:', err);
         }
       }
     });

     // Check for URL parameters on load
     const urlParams = new URLSearchParams(window.location.search);
     const articleParam = urlParams.get('article');
     const chipsParam = urlParams.get('chips');
     const countdownParam = urlParams.get('countdown');

     if (articleParam) {
       document.getElementById('articleInput').value = articleParam;
       if (chipsParam) {
         document.getElementById('chipCountInput').value = chipsParam;
       }
       if (countdownParam) {
         document.getElementById('countdownInput').value = countdownParam;
       }
       checkArticleEdits(articleParam);
     } else {
       // Load a random article on boot if no URL params
       loadRandomArticle();
     }

     // Pause/Resume button
     document.getElementById('pauseBtn').addEventListener('click', () => {
       if (isPaused) {
         // Resume
         isPaused = false;
         document.getElementById('pauseBtn').textContent = 'Pause';

         // Restart countdown from paused value
         if (currentRevisionIndex < allRevisions.length - 1 && chipCount > 0) {
           clearInterval(countdownInterval);
           let count = pausedCountdown;
           document.getElementById('countdown').textContent = count;

           countdownInterval = setInterval(() => {
             count--;
             if (count > 0) {
               document.getElementById('countdown').textContent = count;
             } else {
               clearInterval(countdownInterval);
               nextRevision();
             }
           }, 1000);
         }
       } else {
         // Pause
         isPaused = true;
         document.getElementById('pauseBtn').textContent = 'Resume';
         pausedCountdown = parseInt(document.getElementById('countdown').textContent) || 0;
         clearInterval(countdownInterval);
       }
     });

     // Shared function to clear all placed chips
     function clearAllBets() {
       document.querySelectorAll('.placed-chip').forEach(chip => {
         const chipValue = parseInt(chip.textContent);
         chipCount += chipValue;
         chip.remove();
       });
       document.getElementById('chipCount').textContent = chipCount;
     }

     // Shared function to show end game screen
     function showEndGameScreen() {
       clearInterval(countdownInterval);
       clearAllBets();

       // Get current revision info
       const currentRev = allRevisions[currentRevisionIndex];
       const revisionDate = currentRev ? new Date(currentRev.timestamp).toLocaleString() : 'N/A';

       // Calculate stats
       const netGain = chipCount - totalChipsInserted;

       // Populate end game screen
       document.getElementById('endArticle').textContent = pageTitle;
       document.getElementById('endRevision').textContent = `${currentRevisionIndex + 1} of ${allRevisions.length}`;
       document.getElementById('endRevisionDate').textContent = revisionDate;
       document.getElementById('endChipsInserted').textContent = totalChipsInserted;
       document.getElementById('endChipsWon').textContent = totalChipsWon;
       document.getElementById('endCurrentChips').textContent = chipCount;
       document.getElementById('endNetGain').textContent = netGain >= 0 ? `+${netGain}` : netGain;
       document.getElementById('endNetGain').style.color = netGain >= 0 ? 'green' : 'red';

       // Hide other screens and show end game screen
       document.getElementById('gameOverScreen').classList.add('hidden');
       document.getElementById('endGameScreen').classList.remove('hidden');
     }

     // Clear all bets button
     document.getElementById('clearBetsBtn').addEventListener('click', clearAllBets);

     // End Game button
     document.getElementById('endGameBtn').addEventListener('click', showEndGameScreen);

     // End game from game over screen
     document.getElementById('endGameFromOverBtn').addEventListener('click', showEndGameScreen);

     // Return to Start button
     document.getElementById('returnToStartBtn').addEventListener('click', () => {
       document.getElementById('endGameScreen').classList.add('hidden');
       document.getElementById('container').classList.add('hidden');
       document.getElementById('startScreen').classList.remove('hidden');
       document.getElementById('gameOverScreen').classList.add('hidden');

       // Reset game state
       allRevisions = [];
       revisionHtml = [];
       currentRevisionIndex = 0;
       isPaused = false;
       pausedCountdown = 0;
       totalChipsInserted = 0;
       totalChipsWon = 0;
       document.getElementById('pauseBtn').textContent = 'Pause';

       // Clear placed chips and content
       document.querySelectorAll('.placed-chip').forEach(chip => chip.remove());
       content.innerHTML = '';
     });
    </script>
  </body>
</html>
