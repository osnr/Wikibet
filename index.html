<html>
  <head>
    <style>
      #header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background-color: rgba(255, 255, 255, 0.9);
        border-bottom: 1px solid #ccc;
        padding: 10px;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        align-items: start;
      }
      #countdown {
        font-size: 48px;
        font-weight: bold;
        color: #666;
      }
      #chipTray {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .chip {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 3px solid white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        cursor: grab;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      }
      .chip:active {
        cursor: grabbing;
      }
      .chip.red { background-color: #dc3545; }
      .placed-chip {
        position: absolute;
        pointer-events: none;
        cursor: grab;
        z-index: 999;
      }
      #chipPile {
        position: relative;
      }
      #chipCount {
        font-size: 24px;
      }
      #content {
        margin-top: 120px;
      }
      ins { background-color: #90EE90; text-decoration: none; }
      del { background-color: #FFB6C1; }

      #startScreen {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        gap: 20px;
        padding: 20px;
      }
      #startScreen h1 {
        margin-bottom: 20px;
      }
      #startScreen input, #startScreen button {
        padding: 10px 15px;
        font-size: 16px;
        border-radius: 5px;
        border: 1px solid #ccc;
      }
      #startScreen input {
        width: 300px;
      }
      #startScreen button {
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      #startScreen button:hover {
        background-color: #0056b3;
      }
      #startScreen button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }
      .inputGroup {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 300px;
      }
      .inputGroup label {
        font-weight: bold;
      }
      #articleInfo {
        color: #666;
        font-style: italic;
      }
      #shareUrl {
        width: 400px;
        font-size: 14px;
        background-color: #f5f5f5;
      }
      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="startScreen">
      <h1>Wikipedia Edit Roulette</h1>

      <div class="inputGroup">
        <label for="articleInput">Article name:</label>
        <input type="text" id="articleInput" placeholder="Enter article name (e.g., Apple Inc.)">
        <button id="randomArticleBtn">Random article</button>
      </div>

      <div id="articleInfo"></div>

      <div class="inputGroup">
        <label for="chipCountInput">Starting chips:</label>
        <input type="number" id="chipCountInput" value="5" min="1" max="20">
      </div>

      <div class="inputGroup">
        <label for="countdownInput">Round time (seconds):</label>
        <input type="number" id="countdownInput" value="3" min="1" max="30">
      </div>

      <div class="inputGroup">
        <label for="shareUrl">Share this URL to play this exact game:</label>
        <input type="text" id="shareUrl" readonly>
      </div>

      <button id="startGameBtn" disabled>Start game</button>
    </div>

    <div id="container" class="hidden">
      <div id="header">
        <div id="headerInfo">
        </div>
        <div id="chipTray">
          <div id="chipPile" class="chip red">
            <span id="chipCount">5</span>
          </div>
        </div>
        <div id="countdown">3</div>
      </div>

      <div id="content"></div>
    </div>

    <script>
     // Polyfill for CommonJS module.exports in browser
     var module = { exports: {} };
    </script>
    <script src="vendor/htmldiff.js"></script>
    <script>
     const htmldiff = module.exports.default;

     let allRevisions = [];
     let revisionHtml = [];
     let currentRevisionIndex = 0;
     let pageTitle = '';
     let countdownInterval = null;
     let draggedChip = null;
     let chipCount = 5;
     let selectedArticle = null;
     let countdownTime = 3;

     // Cached audio objects
     const coinSound = new Audio('res/coin.wav');
     const hurtSound = new Audio('res/hurt.wav');

     async function scoreRound() {
       // Check placed chips after content is rendered
       if (currentRevisionIndex == 0) {
         return;
       }

       const placedChips = Array.from(document.querySelectorAll('.placed-chip'));

       for (let i = 0; i < placedChips.length; i++) {
         const chip = placedChips[i];

         // Scroll chip into view if needed
         const headerHeight = document.getElementById('header').offsetHeight;
         chip.scrollIntoView({ behavior: 'smooth', block: 'center' });

         const chipRect = chip.getBoundingClientRect();

         // Check if chip intersects with any ins or del element
         let isOnChange = false;
         const changes = document.querySelectorAll('ins, del');
         for (const change of changes) {
           const changeRect = change.getBoundingClientRect();

           // Check if rectangles intersect
           if (!(chipRect.right < changeRect.left ||
                 chipRect.left > changeRect.right ||
                 chipRect.bottom < changeRect.top ||
                 chipRect.top > changeRect.bottom)) {
             isOnChange = true;
             break;
           }
         }

         // Play sound effect
         const sound = isOnChange ? coinSound : hurtSound;
         sound.currentTime = 0;
         sound.play().catch(e => console.log('Audio play failed:', e));

         // Create overlay animation
         const overlay = document.createElement('div');
         overlay.textContent = isOnChange ? '+5' : '-1';
         overlay.style.position = 'absolute';
         overlay.style.left = chip.style.left;
         overlay.style.top = chip.style.top;
         overlay.style.fontSize = '24px';
         overlay.style.fontWeight = 'bold';
         overlay.style.color = isOnChange ? 'green' : 'red';
         overlay.style.zIndex = '1002';
         overlay.style.pointerEvents = 'none';
         overlay.style.transition = 'opacity 2s, transform 2s';
         overlay.style.transform = 'translateY(0)';
         document.body.appendChild(overlay);

         // Animate and remove
         setTimeout(() => {
           overlay.style.opacity = '0';
           overlay.style.transform = 'translateY(-20px)';
         }, 0);

         setTimeout(() => {
           overlay.remove();
         }, 2000);

         // Update chip count and remove chip
         if (isOnChange) {
           chipCount += 5;
         }
         chip.remove();

         document.getElementById('chipCount').textContent = chipCount;

         // Wait 300ms before next chip
         if (i < placedChips.length - 1) {
           await new Promise(resolve => setTimeout(resolve, 300));
         }
       }
     }

     async function displayRevision() {
       let contentHtml;

       if (currentRevisionIndex === 0) {
         contentHtml = revisionHtml[0];
       } else {
         const oldHtml = revisionHtml[currentRevisionIndex - 1];
         const newHtml = revisionHtml[currentRevisionIndex];
         contentHtml = htmldiff.execute(oldHtml, newHtml);
       }

       headerInfo.innerHTML = `
          <div>Article: ${pageTitle}</div>
          <div>Total number of edits: ${allRevisions.length}</div>
          <div>Showing revision ${currentRevisionIndex + 1} of ${allRevisions.length}</div>
       `;
       content.innerHTML = contentHtml;

       await scoreRound();

       // Click on content to place chip
       content.addEventListener('pointerdown', (e) => {
         if (chipCount <= 0) return;
         if (draggedChip != null) return;

         // Decrement chip count
         chipCount--;
         document.getElementById('chipCount').textContent = chipCount;

         // Create chip at click location
         const chip = document.createElement('div');
         chip.className = 'chip placed-chip red';
         chip.textContent = '1';
         chip.style.left = (e.pageX - 20) + 'px';
         chip.style.top = (e.pageY - 20) + 'px';
         chip.style.pointerEvents = 'auto';
         chip.style.cursor = 'grab';
         document.body.appendChild(chip);

         // Add click handler for re-dragging
         chip.addEventListener('pointerdown', (e) => {
           e.stopPropagation();
           startDragging(chip, false, e);
         });
       });

       // Shared drag logic
       function startDragging(chip, fromPile, e) {
         e.preventDefault();
         e.stopPropagation();

         if (draggedChip != null) return;

         draggedChip = chip;
         draggedChip.style.zIndex = '1001'; // Above header while dragging
         draggedChip.style.pointerEvents = 'none';
         document.body.style.cursor = 'grabbing';

         // Capture pointer to ensure we get all move events
         e.target.setPointerCapture(e.pointerId);

         const onPointerMove = (e) => {
           if (draggedChip) {
             draggedChip.style.left = (e.pageX - 20) + 'px';
             draggedChip.style.top = (e.pageY - 20) + 'px';
           }
         };

         const onPointerUp = (e) => {
           document.body.removeEventListener('pointermove', onPointerMove);
           document.body.removeEventListener('pointerup', onPointerUp);
           document.body.style.cursor = '';

           // Check if pointer is inside header
           const header = document.getElementById('header');
           const headerRect = header.getBoundingClientRect();
           if ((e.clientX >= headerRect.left && e.clientX <= headerRect.right &&
                e.clientY >= headerRect.top && e.clientY <= headerRect.bottom) ||
               e.clientX < 0 || e.clientY < 0) {
             // Put chip back in pile
             chipCount++;
             document.getElementById('chipCount').textContent = chipCount;
             chipPile.style.visibility = 'visible';
             if (draggedChip) {
               draggedChip.remove();
             }
           } else {
             // Dropped outside header - make it stay
             if (draggedChip) {
               draggedChip.style.pointerEvents = 'auto';
               draggedChip.style.zIndex = '999'; // Below header when placed
               draggedChip.style.cursor = 'grab';
             }
           }

           draggedChip = null;
         };

         document.body.addEventListener('pointermove', onPointerMove);
         document.body.addEventListener('pointerup', onPointerUp);
       }

       // Add pointer event drag functionality to chip pile
       chipPile.addEventListener('pointerdown', (e) => {
         if (chipCount <= 0) return;

         console.log("DOWN");

         e.preventDefault();

         if (draggedChip != null) return;

         // Decrement chip count
         chipCount--;
         document.getElementById('chipCount').textContent = chipCount;

         // Create dragging chip
         const chip = document.createElement('div');
         chip.className = 'chip placed-chip red';
         chip.textContent = '1';
         chip.style.left = (e.pageX - 20) + 'px';
         chip.style.top = (e.pageY - 20) + 'px';
         document.body.appendChild(chip);

         // Add click handler for re-dragging
         chip.addEventListener('pointerdown', (e) => {
           startDragging(chip, false, e);
         });

         startDragging(chip, true, e);
       });

       // Start countdown
       if (currentRevisionIndex < allRevisions.length - 1) {
         clearInterval(countdownInterval);
         let count = countdownTime;
         document.getElementById('countdown').textContent = count;

         countdownInterval = setInterval(() => {
           count--;
           if (count > 0) {
             document.getElementById('countdown').textContent = count;
           } else {
             clearInterval(countdownInterval);
             nextRevision();
           }
         }, 1000);
       } else {
         document.getElementById('countdown').textContent = '';
       }

       // Scroll to first change if not the first revision
       // if (currentRevisionIndex > 0) {
       //   setTimeout(() => {
       //     const firstChange = document.querySelector('ins, del');
       //     if (firstChange) {
       //       const headerHeight = document.getElementById('header').offsetHeight;
       //       const elementPosition = firstChange.getBoundingClientRect().top + window.scrollY;
       //       window.scrollTo({
       //         top: elementPosition - headerHeight - 20,
       //         behavior: 'smooth'
       //       });
       //     }
       //   }, 0);
       // }
     }

     async function nextRevision() {
       if (currentRevisionIndex >= allRevisions.length - 1) return;

       currentRevisionIndex++;

       // Fetch content if we don't have it yet
       if (!revisionHtml[currentRevisionIndex]) {
         const revId = allRevisions[currentRevisionIndex].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${revId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[currentRevisionIndex] = contentData.parse.text['*'];
       }

       displayRevision();
     }

     async function fetchRandomArticleEdits() {
       const headers = {
         'User-Agent': 'MediaWiki REST API docs examples/0.1 (https://meta.wikimedia.org/wiki/User:APaskulin_(WMF))'
       };

       try {
         // First, get a random Wikipedia article
         const randomUrl = 'https://en.wikipedia.org/w/api.php?action=query&list=random&rnnamespace=0&rnlimit=1&format=json&origin=*';
         const randomResponse = await fetch(randomUrl);
         const randomData = await randomResponse.json();
         pageTitle = randomData.query.random[0].title;

         headerInfo.innerHTML = `Loading edits for: ${pageTitle}...`;

         // Fetch all revisions (up to 1000 with pagination)
         let continueToken = null;

         while (allRevisions.length < 1000) {
           const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(pageTitle)}&prop=revisions&rvlimit=500&rvdir=newer&format=json&origin=*${continueToken ? '&rvcontinue=' + continueToken : ''}`;
           const historyResponse = await fetch(historyUrl);
           const historyData = await historyResponse.json();
           const page = historyData.query.pages[Object.keys(historyData.query.pages)[0]];

           if (page.revisions) {
             allRevisions = allRevisions.concat(page.revisions);
           }

           if (historyData.continue && historyData.continue.rvcontinue && allRevisions.length < 1000) {
             continueToken = historyData.continue.rvcontinue;
           } else {
             break;
           }
         }

         // Get the original article HTML (first revision)
         const firstRevId = allRevisions[0].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${firstRevId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[0] = contentData.parse.text['*'];

         displayRevision();
       } catch (error) {
         headerInfo.innerHTML = 'Error loading data: ' + error.message;
       }
     }

     // Start screen logic
     async function checkArticleEdits(articleName) {
       try {
         document.getElementById('articleInfo').textContent = 'Checking article...';
         document.getElementById('startGameBtn').disabled = true;

         const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=1&format=json&origin=*`;
         const response = await fetch(historyUrl);
         const data = await response.json();
         const pages = data.query.pages;
         const pageId = Object.keys(pages)[0];

         if (pageId === '-1') {
           document.getElementById('articleInfo').textContent = 'Article not found. Please try another.';
           selectedArticle = null;
           updateShareUrl();
           return;
         }

         // Fetch revision count
         const countUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=500&format=json&origin=*`;
         const countResponse = await fetch(countUrl);
         const countData = await countResponse.json();
         const page = countData.query.pages[Object.keys(countData.query.pages)[0]];

         let revCount = 0;
         if (page.revisions) {
           revCount = page.revisions.length;
           // Note: This is approximate since Wikipedia limits to 500 revisions per query
           if (countData.continue) {
             revCount = '500+';
           }
         }

         selectedArticle = articleName;
         document.getElementById('articleInfo').textContent = `Found: "${articleName}" with ${revCount} edits`;
         document.getElementById('startGameBtn').disabled = false;
         updateShareUrl();
       } catch (error) {
         document.getElementById('articleInfo').textContent = 'Error checking article: ' + error.message;
         selectedArticle = null;
         updateShareUrl();
       }
     }

     function updateShareUrl() {
       const chipCountInput = document.getElementById('chipCountInput').value;
       const countdownInput = document.getElementById('countdownInput').value;
       if (selectedArticle && chipCountInput && countdownInput) {
         const params = new URLSearchParams({
           article: selectedArticle,
           chips: chipCountInput,
           countdown: countdownInput
         });
         const url = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
         document.getElementById('shareUrl').value = url;
       } else {
         document.getElementById('shareUrl').value = '';
       }
     }

     async function loadRandomArticle() {
       try {
         document.getElementById('randomArticleBtn').disabled = true;
         document.getElementById('articleInfo').textContent = 'Loading random article...';

         const randomUrl = 'https://en.wikipedia.org/w/api.php?action=query&list=random&rnnamespace=0&rnlimit=1&format=json&origin=*';
         const response = await fetch(randomUrl);
         const data = await response.json();
         const articleName = data.query.random[0].title;

         document.getElementById('articleInput').value = articleName;
         await checkArticleEdits(articleName);
       } catch (error) {
         document.getElementById('articleInfo').textContent = 'Error loading random article: ' + error.message;
       } finally {
         document.getElementById('randomArticleBtn').disabled = false;
       }
     }

     function startGame() {
       pageTitle = selectedArticle;
       chipCount = parseInt(document.getElementById('chipCountInput').value);
       countdownTime = parseInt(document.getElementById('countdownInput').value);
       document.getElementById('chipCount').textContent = chipCount;

       document.getElementById('startScreen').classList.add('hidden');
       document.getElementById('container').classList.remove('hidden');

       fetchArticleEdits(pageTitle);
     }

     async function fetchArticleEdits(articleName) {
       try {
         headerInfo.innerHTML = `Loading edits for: ${articleName}...`;

         // Fetch all revisions (up to 1000 with pagination)
         allRevisions = [];
         let continueToken = null;

         while (allRevisions.length < 1000) {
           const historyUrl = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(articleName)}&prop=revisions&rvlimit=500&rvdir=newer&format=json&origin=*${continueToken ? '&rvcontinue=' + continueToken : ''}`;
           const historyResponse = await fetch(historyUrl);
           const historyData = await historyResponse.json();
           const page = historyData.query.pages[Object.keys(historyData.query.pages)[0]];

           if (page.revisions) {
             allRevisions = allRevisions.concat(page.revisions);
           }

           if (historyData.continue && historyData.continue.rvcontinue && allRevisions.length < 1000) {
             continueToken = historyData.continue.rvcontinue;
           } else {
             break;
           }
         }

         // Get the original article HTML (first revision)
         const firstRevId = allRevisions[0].revid;
         const contentUrl = `https://en.wikipedia.org/w/api.php?action=parse&oldid=${firstRevId}&format=json&origin=*`;
         const contentResponse = await fetch(contentUrl);
         const contentData = await contentResponse.json();
         revisionHtml[0] = contentData.parse.text['*'];

         displayRevision();
       } catch (error) {
         headerInfo.innerHTML = 'Error loading data: ' + error.message;
       }
     }

     // Event listeners for start screen
     document.getElementById('articleInput').addEventListener('input', (e) => {
       const value = e.target.value.trim();
       if (value) {
         checkArticleEdits(value);
       } else {
         selectedArticle = null;
         document.getElementById('articleInfo').textContent = '';
         document.getElementById('startGameBtn').disabled = true;
         updateShareUrl();
       }
     });

     document.getElementById('chipCountInput').addEventListener('input', () => {
       updateShareUrl();
     });

     document.getElementById('countdownInput').addEventListener('input', () => {
       updateShareUrl();
     });

     document.getElementById('randomArticleBtn').addEventListener('click', loadRandomArticle);
     document.getElementById('startGameBtn').addEventListener('click', startGame);

     // Check for URL parameters on load
     const urlParams = new URLSearchParams(window.location.search);
     const articleParam = urlParams.get('article');
     const chipsParam = urlParams.get('chips');
     const countdownParam = urlParams.get('countdown');

     if (articleParam) {
       document.getElementById('articleInput').value = articleParam;
       if (chipsParam) {
         document.getElementById('chipCountInput').value = chipsParam;
       }
       if (countdownParam) {
         document.getElementById('countdownInput').value = countdownParam;
       }
       checkArticleEdits(articleParam);
     } else {
       // Load a random article on boot if no URL params
       loadRandomArticle();
     }
    </script>
  </body>
</html>
